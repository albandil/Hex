/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 *                                                                           *
 *                       / /   / /    __    \ \  / /                         *
 *                      / /__ / /   / _ \    \ \/ /                          *
 *                     /  ___  /   | |/_/    / /\ \                          *
 *                    / /   / /    \_\      / /  \ \                         *
 *                                                                           *
 *                         Jakub Benda (c) 2013                              *
 *                     Charles University in Prague                          *
 *                                                                           *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#ifndef HEX_ARRITHM
#define HEX_ARRITHM

#include <numeric>
#include <cassert>
#include <map>
#include <vector>

#include "complex.h"

#define Array std::vector

// array name shortcuts
typedef std::vector<double>			rArray;
typedef std::vector<long double>	qArray;
typedef std::vector<Complex>		cArray;

// nested arrays
typedef std::vector<rArray>		rArrays;
typedef std::vector<qArray>		qArrays;
typedef std::vector<cArray>		cArrays;

// return absolute values
inline rArray abs (cArray const &u)
{
	rArray v(u.size());
	
	auto iu = u.begin();
	auto iv = v.begin();
	
	while (iu != u.end())
		*(iv++) = abs(*(iu++));
	
	return v;
}

inline rArrays abs (cArrays const &u)
{
	rArrays v(u.size());
	
	auto iu = u.begin();
	auto iv = v.begin();
	
	while (iu != u.end())
		*(iv++) = abs(*(iu++));
	
	return v;
}

// return greatest element
template <typename T> T max (Array<T> const &u)
{
	if (u.size() == 0)
		throw "[max] Empty vector!";
	
	auto iu = u.begin();
	
	T umax = *iu;
	
	while (++iu != u.end())
		if (*iu > umax)
			umax = *iu;
	
	return umax;
}

// return per-element power
template <typename T> Array<T> pow(Array<T> const &u, double e)
{
	Array<T> v(u.size());
	
	auto iu = u.begin();
	auto iv = v.begin();
	
	while (iu != u.end())
		*(iv++) = pow(*(iu++), e);
	
	return v;
}

//
//   array & array arithmetic
//

template <typename Tu, typename Tv>
auto operator + (Array<Tu> const &u, Array<Tv> const &v) -> Array<decltype(Tu(0)+Tv(0))>
{
	// check lengths
	const size_t Nu = u.size();
	assert(Nu == v.size());
	
	// create output array
	Array<decltype(Tu(0)+Tv(0))> w(Nu);
	
	// compute elements
	for (size_t i = 0; i < Nu; i++)
		w[i] = u[i] + v[i];
	
	// return the result
	return w;
}

template <typename A, typename B>
auto operator - (Array<A> const &u, Array<B> const &v) -> Array<decltype(A(0)+B(0))>
{
	// check lengths
	const size_t Nu = u.size();
	assert(Nu == v.size());
	
	// create output array
	Array<decltype(A(0)+B(0))> w(Nu);
	
	// compute elements
	for (size_t  i = 0; i < Nu; i++)
		w[i] = u[i] - v[i];
	
	// return the result
	return w;
}

template <typename A, typename B> 
auto operator * (Array<A> const &u, Array<B> const &v) -> Array<decltype(A(0)*B(0))>
{
	// check lengths
	const size_t Nu = u.size();
	assert(Nu == v.size());
	
	// create output array
	Array<decltype(A(0)*B(0))> w(Nu);
	
	// compute elements
	for (size_t  i = 0; i < Nu; i++)
		w[i] = u[i] * v[i];
	
	// return the result
	return w;
}

template <typename A, typename B> 
auto operator / (Array<A> const &u, Array<B> const &v) -> Array<decltype(A(0)*B(0))>
{
	// check lengths
	const size_t Nu = u.size();
	assert(Nu == v.size());
	
	// create output array
	Array<decltype(A(0)*B(0))> w(Nu);
	
	// compute elements
	for (size_t  i = 0; i < Nu; i++)
		w[i] = u[i] / v[i];
	
	// return the result
	return w;
}

//
//   scalar-array arithmetic
//

template <typename A, typename B> 
auto operator * (A u, Array<B> const &v) -> Array<decltype(A(0)*B(0))>
{
	const size_t Nv = v.size();
	
	// create output array
	Array<decltype(A(0)*B(0))> w(Nv);
	
	// compute elements
	for (size_t  i = 0; i < Nv; i++)
		w[i] = u * v[i];
	
	// return the result
	return w;
}

template <typename A, typename B> 
auto operator * (Array<A> const &u, B v) -> Array<decltype(A(0)*B(0))>
{
	const size_t Nu = u.size();
	
	// create output array
	Array<decltype(A(0)*B(0))> w(Nu);
	
	// compute elements
	for (size_t  i = 0; i < Nu; i++)
		w[i] = u[i] * v;
	
	// return the result
	return w;
}

template <typename A, typename B> 
auto operator / (A u, Array<B> const &v) -> Array<decltype(A(0)/B(0))>
{
	const size_t Nv = v.size();
	
	// create output array
	Array<decltype(A(0)*B(0))> w(Nv);
	
	// compute elements
	for (size_t  i = 0; i < Nv; i++)
		w[i] = u / v[i];
	
	// return the result
	return w;
}

template <typename A, typename B> 
auto operator / (Array<A> const &u, B v) -> Array<decltype(A(0)/B(0))>
{
	const size_t Nu = u.size();
	
	// create output array
	Array<decltype(A(0)*B(0))> w(Nu);
	
	// compute elements
	for (size_t  i = 0; i < Nu; i++)
		w[i] = u[i] / v;
	
	// return the result
	return w;
}

// boolean aggregation
bool all(Array<bool> v);
bool any(Array<bool> v);

// summation
template <typename T> T sum(Array<T> v)
{
	return std::accumulate(v.begin(), v.end(), T(0));
}

// summation of nested arrays
template <typename T> Array<T> sums(Array<Array<T>> v)
{
	if (v.size() == 0)
		return Array<T>();	// empty array
	
	return std::accumulate(
		v.begin(),
		v.end(),
		Array<T> (v[0].size()),
		[](Array<T> a, Array<T> b) -> Array<T> {
			return a + b;
		}
	);
}

/**
 * Comparison of an array and a number.
 * \param u Array.
 * \param x Number.
 * \return Vector of bools for element-wise comparisons.
 */
template <typename T>
Array<bool> operator == (Array<T> u, T x)
{
	Array<bool> v(u.size());
	for (size_t i  = 0; i < u.size(); i++)
		v[i] = (u[i] == x);
	return v;
}

/**
 * Evaluation of a function over a grid.
 * \param f Functor to be evaluated using the operator() (double) interface.
 * \param grid Array-like type containing the evaluation points.
 * \param vals Array-like type to hold evaluated function on return. It is
 *             required that enough space is reserved, at least grid.size().
 */
template <typename TFunctor, typename TArray>
void eval(TFunctor f, TArray grid, TArray& vals)
{
	size_t N = grid.size();
	assert(N == vals.size());
	
	for (size_t i = 0; i < N; i++)
		vals[i] = f(grid[i]);
}

/**
 * Create equidistant grid.
 */
rArray linspace(double x0, double x1, unsigned N);

/**
 * Create logarithmic grid.
 */
rArray logspace(double x0, double x1, unsigned N);

/**
 * Load / save array from a HDF5 file.
 */
bool load_array(rArray& vec, const char* name, double* pdelta = 0);
bool load_array(cArray& vec, const char* name);
bool save_array(rArray const & vec, const char* name, const double * const pdelta = 0);
bool save_array(cArray const & vec, const char* name);

/**
 * Write array to a text file.
 */
void write_array(const std::map<unsigned long long, Complex>& m, const char* filename);
void write_array(rArray const & grid, rArray const & array, const char* filename);
void write_array(rArray const & array, const char* filename);
void write_array(cArray const & array, const char* filename);
void write_array(rArray const & grid, cArray const & array, const char* filename);
void write_array(qArray const & array, const char* filename);

#endif
