/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 *                                                                           *
 *                       / /   / /    __    \ \  / /                         *
 *                      / /__ / /   / _ \    \ \/ /                          *
 *                     /  ___  /   | |/_/    / /\ \                          *
 *                    / /   / /    \_\      / /  \ \                         *
 *                                                                           *
 *                         Jakub Benda (c) 2013                              *
 *                     Charles University in Prague                          *
 *                                                                           *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#include <tuple>

#include "arrays.h"
#include "dwba2.h"
#include "hydrogen.h"
#include "integrate.h"
#include "potential.h"
#include "specf.h"
#include "wave_distort.h"

// precomputed Sturmian functions for given N and L
std::map<std::pair<int,int>,SturmianFunction> DWBA2::sturmians;

// precomputed 1-D integrals for given λ, lα, kα, N and L
std::map<std::tuple<    int,double,int,int>,RadialFunction<double> const*> DWBA2::phi0_int;  // λ = 0
std::map<std::tuple<int,int,double,int,int>,RadialFunction<double> const*> DWBA2::phi12_int; // λ ≠ 0
std::map<std::tuple<int,int,double,int,int>,RadialFunction<double> const*> DWBA2::phi3_int;  // λ ≠ 0

// precomputed 1-D integrals for given α, N, L
std::map<std::tuple<char,int,int>,double> DWBA2::PSr_int;

// precomputed 1-D integrals for given α, lα, kα, N and L
std::map<std::tuple<char,int,double,int,int>,double> DWBA2::UxSr_int;

void DWBA2::update_cache (
	int lami, int li, double ki, HydrogenFunction const & psii, DistortedWave const & chii, DistortingPotential const & Ui,
	int lamf, int lf, double kf, HydrogenFunction const & psif, DistortedWave const & chif, DistortingPotential const & Uf,
	int L1, int L2, int N
) {
	// prepare Sturmian functions
	for (int N1 = L1 + 1; N1 <= L1 + N; N1++)
	{
		if (sturmians.find(std::make_pair(N1,L1)) == sturmians.end())
		{
			sturmians[std::make_pair(N1,L1)] = SturmianFunction(N1,L1);
			
			char name[50];
			sprintf(name, "s-%d-%d.dat", N1, L1);
			sturmians[std::make_pair(N1,L1)].toFile(name);
		}
	}
	for (int N2 = L2 + 1; N2 <= L2 + N; N2++)
	{
		if (sturmians.find(std::make_pair(N2,L2)) == sturmians.end())
		{
			sturmians[std::make_pair(N2,L2)] = SturmianFunction(N2,L2);
			char name[50];
			sprintf(name, "s-%d-%d.dat", L2, L2);
			sturmians[std::make_pair(N2,L2)].toFile(name);
		}
	}
	
	// precompute inner integration functions φ₀
	for (int N1 = L1 + 1; N1 <= L1 + N; N1++)
	{
		if (lami == 0)
		{
			auto idi = std::make_tuple(li,ki,N1,L1);
			if (phi0_int.find(idi) == phi0_int.end())
			{
				phi0_int[idi] = new PhiFunction0 (li, ki, chii, N1, L1, sturmians[std::make_pair(N1,L1)]);
				
				char name[60];
				sprintf(name, "phi0-%d-%g-%d-%d.dat", li, ki, N1, L1);
				rArray grid = linspace(0., 200., 2001);
				rArray eval = phi0_int[idi]->getValues(grid);
				write_array (grid, eval, name);
			}
		}
		if (lamf == 0)
		{
			auto idf = std::make_tuple(lf,kf,N1,L1);
			if (phi0_int.find(idf) == phi0_int.end())
				phi0_int[idf] = new PhiFunction0 (lf, kf, chif, N1, L1, sturmians[std::make_pair(N1,L1)]);
		}
	}
	for (int N2 = L2 + 1; N2 <= L2 + N; N2++)
	{
		if (lami == 0)
		{
			auto idi = std::make_tuple(li,ki,N2,L2);
			if (phi0_int.find(idi) == phi0_int.end())
				phi0_int[idi] = new PhiFunction0 (li, ki, chii, N2, L2, sturmians[std::make_pair(N2,L2)]);
		}
		if (lamf == 0)
		{
			auto idf = std::make_tuple(lf,kf,N2,L2);
			if (phi0_int.find(idf) == phi0_int.end())
				phi0_int[idf] = new PhiFunction0 (lf, kf, chif, N2, L2, sturmians[std::make_pair(N2,L2)]);
		}
	}
	
	// precompute inner integration functions φ₁, φ₂
	for (int N1 = L1 + 1; N1 <= L1 + N; N1++)
	{
		auto idi = std::make_tuple(lami,li,ki,N1,L1);
		if (phi12_int.find(idi) == phi12_int.end())
		{
			phi12_int[idi] = new PhiFunction12(lami, li, ki, chii, N1, L1, sturmians[std::make_pair(N1,L1)]);
			
			char name[60];
			sprintf(name, "phi12-%d-%d-%g-%d-%d.dat", lami, li, ki, N1, L1);
			rArray grid = linspace(0., 200., 2001);
			rArray eval = phi12_int[idi]->getValues(grid);
			write_array (grid, eval, name);
		}
		auto idf = std::make_tuple(lamf,lf,kf,N1,L1);
		if (phi12_int.find(idf) == phi12_int.end())
			phi12_int[idf] = new PhiFunction12(lamf, lf, kf, chif, N1, L1, sturmians[std::make_pair(N1,L1)]);
	}
	for (int N2 = L2 + 1; N2 <= L2 + N; N2++)
	{
		auto idi = std::make_tuple(lami,li,ki,N2,L2);
		if (phi12_int.find(idi) == phi12_int.end())
			phi12_int[idi] = new PhiFunction12(lami, li, ki, chii, N2, L2, sturmians[std::make_pair(N2,L2)]);
		auto idf = std::make_tuple(lamf,lf,kf,N2,L2);
		if (phi12_int.find(idf) == phi12_int.end())
			phi12_int[idf] = new PhiFunction12(lamf, lf, kf, chif, N2, L2, sturmians[std::make_pair(N2,L2)]);
	}
	
	// precompute inner integration functions φ₃
	for (int N1 = L1 + 1; N1 <= L1 + N; N1++)
	{
		auto idi = std::make_tuple(lami,li,ki,N1,L1);
		if (phi3_int.find(idi) == phi3_int.end())
		{
			phi3_int[idi] = new PhiFunction3(lami, li, ki, chii, N1, L1, sturmians[std::make_pair(N1,L1)]);
			
			char name[60];
			sprintf(name, "phi3-%d-%d-%g-%d-%d.dat", lami, li, ki, N1, L1);
			rArray grid = linspace(0., 200., 2001);
			rArray eval = phi3_int[idi]->getValues(grid);
			write_array (grid, eval, name);
		}
		auto idf = std::make_tuple(lamf,lf,kf,N1,L1);
		if (phi3_int.find(idf) == phi3_int.end())
			phi3_int[idf] = new PhiFunction3(lamf, lf, kf, chif, N1, L1, sturmians[std::make_pair(N1,L1)]);
	}
	for (int N2 = L2 + 1; N2 <= L2 + N; N2++)
	{
		auto idi = std::make_tuple(lami,li,ki,N2,L2);
		if (phi3_int.find(idi) == phi3_int.end())
			phi3_int[idi] = new PhiFunction3(lami, li, ki, chii, N2, L2, sturmians[std::make_pair(N2,L2)]);
		auto idf = std::make_tuple(lamf,lf,kf,N2,L2);
		if (phi3_int.find(idf) == phi3_int.end())
			phi3_int[idf] = new PhiFunction3(lamf, lf, kf, chif, N2, L2, sturmians[std::make_pair(N2,L2)]);
	}
	
	// precompute separate 1-D integrations
	for (int N1 = L1 + 1; N1 <= L1 + N; N1++)
	{
		auto idi = std::make_tuple('i',N1,L1);
		if (PSr_int.find(idi) == PSr_int.end())
		{
			auto integrand = [ & ](double x) -> double {
				return psii.getValue(x) * sturmians[std::make_pair(N1,L1)].getValue(x) * x;
			};
			Integrator<decltype(integrand)> Q(integrand);
			Q.integrate(0, std::numeric_limits<double>::infinity());
			PSr_int[idi] = Q.result();
		}
		
		auto idf = std::make_tuple('f',N1,L1);
		if (PSr_int.find(idf) == PSr_int.end())
		{
			auto integrand = [ & ](double x) -> double {
				return psif.getValue(x) * sturmians[std::make_pair(N1,L1)].getValue(x) * x;
			};
			Integrator<decltype(integrand)> Q(integrand);
			Q.integrate(0, std::numeric_limits<double>::infinity());
			PSr_int[idf] = Q.result();
		}
	}
	for (int N2 = L2 + 1; N2 <= L2 + N; N2++)
	{
		auto idi = std::make_tuple('i',N2,L2);
		if (PSr_int.find(idi) == PSr_int.end())
		{
			auto integrand = [ & ](double x) -> double {
				return psii.getValue(x) * sturmians[std::make_pair(N2,L2)].getValue(x) * x;
			};
			Integrator<decltype(integrand)> Q(integrand);
			Q.integrate(0, std::numeric_limits<double>::infinity());
			PSr_int[idi] = Q.result();
		}
		
		auto idf = std::make_tuple('f',N2,L2);
		if (PSr_int.find(idf) == PSr_int.end())
		{
			auto integrand = [ & ](double x) -> double {
				return psif.getValue(x) * sturmians[std::make_pair(N2,L2)].getValue(x) * x;
			};
			Integrator<decltype(integrand)> Q(integrand);
			Q.integrate(0, std::numeric_limits<double>::infinity());
			PSr_int[idf] = Q.result();
		}
	}
	
	for (int N1 = L1 + 1; N1 <= L1 + N; N1++)
	{
		auto idi = std::make_tuple('i',li,ki,N1,L1);
		if (UxSr_int.find(idi) == UxSr_int.end())
		{
			auto integrand = [ & ](double x) -> double {
				return Ui.getValue(x) * chii.getValue(x) * sturmians[std::make_pair(N1,L1)].getValue(x) * x;
			};
			Integrator<decltype(integrand)> Q(integrand);
			Q.integrate(0, std::numeric_limits<double>::infinity());
			UxSr_int[idi] = Q.result();
		}
		
		auto idf = std::make_tuple('f',li,ki,N1,L1);
		if (UxSr_int.find(idf) == UxSr_int.end())
		{
			auto integrand = [ & ](double x) -> double {
				return Uf.getValue(x) * chif.getValue(x) * sturmians[std::make_pair(N1,L1)].getValue(x) * x;
			};
			Integrator<decltype(integrand)> Q(integrand);
			Q.integrate(0, std::numeric_limits<double>::infinity());
			UxSr_int[idf] = Q.result();
		}
	}
	for (int N2 = L2 + 1; N2 <= L2 + N; N2++)
	{
		auto idi = std::make_tuple('i',li,ki,N2,L2);
		if (UxSr_int.find(idi) == UxSr_int.end())
		{
			auto integrand = [ & ](double x) -> double {
				return Ui.getValue(x) * chii.getValue(x) *  sturmians[std::make_pair(N2,L2)].getValue(x) * x;
			};
			Integrator<decltype(integrand)> Q(integrand);
			Q.integrate(0, std::numeric_limits<double>::infinity());
			UxSr_int[idi] = Q.result();
		}
		
		auto idf = std::make_tuple('f',li,ki,N2,L2);
		if (UxSr_int.find(idf) == UxSr_int.end())
		{
			auto integrand = [ & ](double x) -> double {
				return Uf.getValue(x) * chif.getValue(x) * sturmians[std::make_pair(N2,L2)].getValue(x) * x;
			};
			Integrator<decltype(integrand)> Q(integrand);
			Q.integrate(0, std::numeric_limits<double>::infinity());
			UxSr_int[idf] = Q.result();
		}
	}
}

DWBA2::PhiFunction0::PhiFunction0(int la, double ka, DistortedWave const & chia, int Nj, int Lj, SturmianFunction const& sturm)
	: La(la), Ka(ka), Chia (chia), NJ(Nj), LJ(Lj), S(sturm)
{
	init();
}

void DWBA2::PhiFunction0::init()
{
	// get far value
	double far = std::max(Chia.farRadius(), S.farRadius());
	
	// get sample density
	double density = std::max(
		Chia.sampleCount()/Chia.farRadius(), 
		S.sampleCount()/S.farRadius()
	);
	
	// setup grid
	grid = linspace (0., far, far * density);
	array.resize(grid.size());
	
	// setup integrand
	auto integrand = [ & ](double x) -> double {
		return Chia.getValue(x) * S.getValue(x);
	};
	Integrator<decltype(integrand)> Q(integrand);
	
	// integrate
	array[0] = 0.;
	for (size_t i = 1; i < grid.size(); i++)
	{
		Q.integrate(grid[i-1], grid[i]);
		array[i] = array[i-1] + Q.result();
	}
	
	// multiply by coordinate
	array *= grid;
	
	// setup interpolator
	interpolator.set(grid, array, grid.size());
	
	// compute asymptotic integral at the end of grid
// 	Phi_R = PhiIntegral(0,Ka,NJ,LJ,far);
}

double DWBA2::PhiFunction0::getValue(double x) const
{
	// interpolate
	if (x < grid.back())
	{
		return interpolator.interp(x);
	}
	
	// or evaluate asymptotic form
	else
	{
/*
		// evaluate asymptotic integral
		Complex Phi_r = PhiIntegral(0,Ka,NJ,LJ,x);
		
		// compute the result
		return cos(Chia.getPhase() - 0.5 * M_PI * La) * x * (Phi_R.imag() - Phi_r.imag())
		     + sin(Chia.getPhase() - 0.5 * M_PI * La) * x * (Phi_R.real() - Phi_r.real());
*/
		return array.back() * (x / grid.back());
	}
}

DWBA2::PhiFunction12::PhiFunction12(
	int lama, int la, double ka, DistortedWave const & chia,
	int Nj, int Lj, SturmianFunction const& sturm)
	: Lama(lama), La(la), Ka(ka), Chia (chia), NJ(Nj), LJ(Lj), S(sturm)
{	
	init();
}

void DWBA2::PhiFunction12::init()
{
	// get far value
	double far = std::max(Chia.farRadius(), S.farRadius());
	
	// get sample density
	double density = std::max(
		Chia.sampleCount()/Chia.farRadius(), 
		S.sampleCount()/S.farRadius()
	);
	
	// setup grid
	grid = linspace (0., far, far * density);
	array.resize(grid.size());
	
	// setup integrand
	auto integrand = [ & ](double x) -> double {
		return pow(x,Lama+1) * Chia.getValue(x) * S.getValue(x);
	};
	Integrator<decltype(integrand)> Q(integrand);
	
	// integrate
	array[0] = 0.;
	for (size_t i = 1; i < grid.size(); i++)
	{
		Q.integrate(grid[i-1], grid[i]);
		array[i] = array[i-1] + Q.result();
	}
	
	// multiply by coordinate
	array *= pow(grid,-Lama);
	
	// setup interpolator
	interpolator.set(grid, array, grid.size());
	
	// compute asymptotic integral at the end of grid
// 	Phi_R = PhiIntegral(Lama+1,Ka,NJ,LJ,far);
}

double DWBA2::PhiFunction12::getValue(double x) const
{
	// interpolate
	if (x < grid.back())
	{
		return interpolator.interp(x);
	}
	
	// or evaluate asymptotic form
	else
	{
/*
		// evaluate asymptotic integral
		Complex Phi_r = PhiIntegral(Lama+1,Ka,NJ,LJ,x);
		
		// compute multipole
		double x_mLama = pow(x,-Lama);
		
		// compute the result
		return cos(Chia.getPhase() - 0.5 * M_PI * La) * x_mLama * (Phi_R.imag() - Phi_r.imag())
		     + sin(Chia.getPhase() - 0.5 * M_PI * La) * x_mLama * (Phi_R.real() - Phi_r.real());
*/
		return array.back() * pow(x / grid.back(), -Lama);
	}
}

DWBA2::PhiFunction3::PhiFunction3(
	int lama, int la, double ka, DistortedWave const& chia,
	int Nj, int Lj, SturmianFunction const& sturm)
	: Lama(lama), La(la), Ka(ka), Chia(chia), NJ(Nj), LJ(Lj), S(sturm)
{	
	init();
}

void DWBA2::PhiFunction3::init()
{
	// get far value
	double far = std::max(Chia.farRadius(), S.farRadius());
	
	// get sample density
	double density = std::max(
		Chia.sampleCount()/Chia.farRadius(), 
		S.sampleCount()/S.farRadius()
	);
	
	// setup grid
	grid = linspace (0., far, far * density);
	array.resize(grid.size());
	
	// setup integrand
	auto integrand = [ & ](double x) -> double {
		return pow(x,-Lama) * Chia.getValue(x) * S.getValue(x);
	};
	Integrator<decltype(integrand)> Q(integrand);
	
	// integrate
	array[0] = 0.;
	for (size_t i = 1; i < grid.size(); i++)
	{
		Q.integrate(grid[i-1], grid[i]);
		array[i] = array[i-1] + Q.result();
	}
	
	// multiply by coordinate
	array *= pow(grid,Lama+1);
	
	// setup interpolator
	interpolator.set(grid, array, grid.size());
}

double DWBA2::PhiFunction3::getValue(double x) const
{
	// interpolate
	if (x < grid.back())
	{
		return interpolator.interp(x);
	}
	
	// or evaluate asymptotic form
	else
	{
/*
		// evaluate asymptotic integral
		Complex Phi_r = PhiIntegral(-Lama,Ka,NJ,LJ,x);
		
		// compute multipole
		double x_Lamap1 = pow(x,Lama+1);
		
		// compute the result
		return cos(Chia.getPhase() - 0.5 * M_PI * La) * x_Lamap1 * Phi_r.imag()
		     + sin(Chia.getPhase() - 0.5 * M_PI * La) * x_Lamap1 * Phi_r.real();
*/
		return 0;
	}
}

Complex DWBA2::PhiIntegral (int a, double k, int n, int l, double r)
{
	if (n < l + 1)
	{
		// 'n' has to be larger (or equal) than 'l + 1'
		return 0.;
	}
	else if (n == l + 1)
	{
		// return closed form
		return pow(2,l+1) / sqrt(gsl_sf_fact(2*l+1)) * cgamma(a+l+1,Complex(1.,-k)*r) / pow(Complex(1.,-k),a+l+1);
	}
	else
	{
		// use recurrence
		return 2. / ALPHA_MINUS(n-1,l) * (
			(n-1.) * PhiIntegral(a,k,n-1,l,r)
			- PhiIntegral(a+1,k,n-1,l,r)
			- 0.5 * ALPHA_PLUS(n-1,l) * PhiIntegral(a,k,n-2,l,r)
		);
	}
}
