//  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  //
//                                                                                   //
//                       / /   / /    __    \ \  / /                                 //
//                      / /__ / /   / _ \    \ \/ /                                  //
//                     /  ___  /   | |/_/    / /\ \                                  //
//                    / /   / /    \_\      / /  \ \                                 //
//                                                                                   //
//                                                                                   //
//  Copyright (c) 2015, Jakub Benda, Charles University in Prague                    //
//                                                                                   //
// MIT License:                                                                      //
//                                                                                   //
//  Permission is hereby granted, free of charge, to any person obtaining a          //
// copy of this software and associated documentation files (the "Software"),        //
// to deal in the Software without restriction, including without limitation         //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,          //
// and/or sell copies of the Software, and to permit persons to whom the             //
// Software is furnished to do so, subject to the following conditions:              //
//                                                                                   //
//  The above copyright notice and this permission notice shall be included          //
// in all copies or substantial portions of the Software.                            //
//                                                                                   //
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS          //
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,       //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE       //
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, //
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF         //
// OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  //
//                                                                                   //
//  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  //

#ifndef NO_OPENCL

#include <iostream>
#include <set>

#include "../arrays.h"
#include "../clarrays.h"
#include "../gauss.h"
#include "../itersolve.h"
#include "../misc.h"
#include "../preconditioners.h"
#include "../radial.h"

#include <CL/cl.h>

const std::string GPUCGPreconditioner::name = "GPU";
const std::string GPUCGPreconditioner::description = "Block inversion using conjugate gradients preconditioned by Kronecker product approximation (on GPU).";

// kernels' source as byte array, generated by "xxd" from the CL source
char kernels_cl[] = {
    #include "GPUPreconditioner.inc"
    , 0x00 // terminate the string by zero
};

// pointer to the source; to be used in setup
char * source = &kernels_cl[0];

void GPUCGPreconditioner::setup ()
{
    // compute memory requirements of the preconditioner
    int order = s_bspline_.order();
    int Nspline = s_bspline_.Nspline();
    int maxell = inp_.maxell;
    unsigned long req = ((maxell+1) * (Nspline + 2*Nspline*Nspline) + (2*order+1)*(2*order+1)*Nspline*Nspline + 3*Nspline*Nspline) * 16;
    
    std::cout << "Setting up OpenCL environment" << std::endl;
    char text [1000];
    
    // use platform 0
    clGetPlatformIDs(1, &platform_, nullptr);
    clGetPlatformInfo(platform_, CL_PLATFORM_NAME, sizeof(text), text, nullptr);
    std::cout << "\tplatform: " << text << " ";
    clGetPlatformInfo(platform_, CL_PLATFORM_VENDOR, sizeof(text), text, nullptr);
    std::cout << "(" << text << ")" << std::endl;
    clGetPlatformInfo(platform_, CL_PLATFORM_VERSION, sizeof(text), text, nullptr);
    std::cout << "\tavailable version: " << text << std::endl;
    
    // use device 0
//     clGetDeviceIDs (platform_, CL_DEVICE_TYPE_GPU, 1, &device_, nullptr);
    clGetDeviceIDs(platform_, CL_DEVICE_TYPE_CPU, 1, &device_, nullptr);
    clGetDeviceInfo(device_, CL_DEVICE_NAME, sizeof(text), text, nullptr);
    std::cout << "\tdevice: " << text << " ";
    clGetDeviceInfo(device_, CL_DEVICE_VENDOR, sizeof(text), text, nullptr);
    std::cout << "(" << text << ")" << std::endl;
    cl_ulong size;
    clGetDeviceInfo(device_, CL_DEVICE_LOCAL_MEM_SIZE, sizeof(cl_ulong), &size, 0);
    std::cout << "\tlocal memory size: " << size/1024 << " kiB" << std::endl;
    clGetDeviceInfo(device_, CL_DEVICE_GLOBAL_MEM_SIZE, sizeof(cl_ulong), &size, 0);
    std::cout << "\tglobal memory size: " << format("%.2f", size/pow(1024,3)) << " GiB ";
    std::cout << "(appx. " << format("%.2f", req * 100. / size) << " % will be used)" << std::endl;
    clGetDeviceInfo(device_, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(cl_ulong), &size, 0);
    std::cout << "\tmax compute units: " << size << std::endl;
    clGetDeviceInfo(device_, CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(cl_ulong), &size, 0);
    std::cout << "\tmax work group size: " << size << std::endl << std::endl;
    
    // choose (e.g.) the largest workgroup
    // NOTE : This may not be the most efficient choice.
    Nlocal_ = size;
    
    // create context and command queue
    context_ = clCreateContext(nullptr, 1, &device_, nullptr, nullptr, nullptr);
    queue_ = clCreateCommandQueueWithProperties(context_, device_, nullptr, nullptr);
    
    // setup the structure of the matrices
    iArray diags;
    for (int i = -order; i <= order; i++)
        for (int j = -order; j <= order; j++)
            diags.push_back(i * Nspline + j);
    std::string diagonals = to_string(diags, ',');
    
    // setup compile flags
    std::ostringstream flags;
    flags << " -cl-fast-relaxed-math ";
    flags << " -D ORDER="     << order     << " ";
    flags << " -D NSPLINE="   << Nspline   << " ";
    flags << " -D DIAGONALS=" << diagonals << " ";
    flags << " -D NLOCAL="    << Nlocal_   << " ";
    
    // build program
    program_ = clCreateProgramWithSource(context_, 1, const_cast<const char**>(&source), nullptr, nullptr);
    clBuildProgram(program_, 1, &device_, flags.str().c_str(), nullptr, nullptr);
    
    cl_build_status status;
    clGetProgramBuildInfo(program_, device_, CL_PROGRAM_BUILD_STATUS, sizeof(status), &status, nullptr);
    if (status != CL_SUCCESS)
    {
        std::cout << std::endl << "Source:" << std::endl << source << std::endl;
        std::cout << std::endl << "Command line:" << std::endl << flags.str() << std::endl << std::endl;
        
        char log [100000];
        clGetProgramBuildInfo(program_, device_, CL_PROGRAM_BUILD_LOG, sizeof(log), log, nullptr);
        std::cout << "clGetProgramBuildInfo: log" << std::endl << log << std::endl;
        
        HexException("Failed to initialize OpenCL.");
    }
    
    // set program entry points
    mmul_ = clCreateKernel(program_, "mmul",        nullptr);
    amul_ = clCreateKernel(program_, "vec_mul_vec", nullptr);
    axby_ = clCreateKernel(program_, "a_vec_b_vec", nullptr);
    vnrm_ = clCreateKernel(program_, "vec_norm",    nullptr);
    norm_ = clCreateKernel(program_, "norm",        nullptr);
    spro_ = clCreateKernel(program_, "scalar_product", nullptr);
    krd1_ = clCreateKernel(program_, "kron_dot1",   nullptr);
    krd2_ = clCreateKernel(program_, "kron_dot2",   nullptr);
    krdv_ = clCreateKernel(program_, "kron_div",    nullptr);
    
    std::cout << "Set up GPU preconditioner" << std::endl;
    
    KPACGPreconditioner::setup();
}

void GPUCGPreconditioner::precondition (const cArrayView r, cArrayView z) const
{
    // shorthands
    std::size_t Nspline = s_rad_.bspline().Nspline();
    std::size_t Nsegsiz = Nspline * Nspline;
    
    // iterations
    iArray n (l1_l2_.size());
    
    // some OpenCL auxiliary storage arrays (used by kernels for temporary data)
    clArray<Complex> tmp ((Nsegsiz + Nlocal_ - 1) / Nlocal_);  tmp.connect(context_, CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR);
    clArray<double>  nrm ((Nsegsiz + Nlocal_ - 1) / Nlocal_);  nrm.connect(context_, CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR);
    clArray<Complex> tmA (Nspline * Nspline);                  tmA.connect(context_, CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR);
    
    // create OpenCL representation of the one-electron matrices + transfer data to GPU memory
    clArrayView<Complex> S_p (s_rad_.S_p().size(), s_rad_.S_p().data()); S_p.connect(context_, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    clArrayView<Complex> D_p (s_rad_.D_p().size(), s_rad_.D_p().data()); D_p.connect(context_, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    clArrayView<Complex> Mm1_tr_p (s_rad_.Mm1_tr_p().size(), s_rad_.Mm1_tr_p().data()); Mm1_tr_p.connect(context_, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    clArrayView<Complex> Mm2_p (s_rad_.Mm2_p().size(), s_rad_.Mm2_p().data()); Mm2_p.connect(context_, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    clArrayView<Complex> Mi_L (s_rad_.Mitr_L(-1).size(), s_rad_.Mitr_L(-1).data()); Mi_L.connect(context_, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    clArrayView<Complex> Mi_mLm1 (s_rad_.Mitr_mLm1(-1).size(), s_rad_.Mitr_mLm1(-1).data()); Mi_mLm1.connect(context_, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    
    // maximal angular momentum transfer
    int max_lambda = s_rad_.maxlambda();
    
    // for all diagonal blocks
    for (unsigned ill = 0; ill < l1_l2_.size(); ill++) if (par_.isMyWork(ill))
    {
        // get angular momenta
        int l1 = l1_l2_[ill].first;
        int l2 = l1_l2_[ill].second;
        
        // create segment views
        clArrayView<Complex> rview (r, (ill / par_.Nproc()) * Nsegsiz, Nsegsiz); rview.connect(context_, CL_MEM_READ_ONLY  | CL_MEM_COPY_HOST_PTR);
        clArrayView<Complex> zview (z, (ill / par_.Nproc()) * Nsegsiz, Nsegsiz); zview.connect(context_, CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR);
        
        // preconditioner matrices
        clArrayView<Complex> prec1a (Nspline * Nspline, prec_[l1].invCl_invsqrtS.data().data()); prec1a.connect(context_, CL_MEM_READ_ONLY  | CL_MEM_COPY_HOST_PTR);
        clArrayView<Complex> prec2a (Nspline * Nspline, prec_[l2].invCl_invsqrtS.data().data()); prec2a.connect(context_, CL_MEM_READ_ONLY  | CL_MEM_COPY_HOST_PTR);
        clArrayView<Complex> Dl1 (Nspline, prec_[l1].Dl.data()); Dl1.connect(context_, CL_MEM_READ_ONLY  | CL_MEM_COPY_HOST_PTR);
        clArrayView<Complex> Dl2 (Nspline, prec_[l2].Dl.data()); Dl2.connect(context_, CL_MEM_READ_ONLY  | CL_MEM_COPY_HOST_PTR);
        clArrayView<Complex> prec1b (Nspline * Nspline, prec_[l1].invsqrtS_Cl.data().data()); prec1b.connect(context_, CL_MEM_READ_ONLY  | CL_MEM_COPY_HOST_PTR);
        clArrayView<Complex> prec2b (Nspline * Nspline, prec_[l2].invsqrtS_Cl.data().data()); prec1b.connect(context_, CL_MEM_READ_ONLY  | CL_MEM_COPY_HOST_PTR);
        
        // allocation (and upload) of an OpenCL array
        auto new_opencl_array = [&](std::size_t n) -> clArray<Complex>
        {
            // create array
            clArray<Complex> a(n);
            
            // connect the array to GPU
            a.connect(context_, CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR);
            
            // use this array
            return a;
        };
        
        // multiplies vector by the ill-th diagonal block (approximate)
        auto inner_mmul = [&](const clArrayView<Complex> a, const clArrayView<Complex> b) -> void
        {
            // multiply
            //      b = A · a
            clSetKernelArg(mmul_,  0, sizeof(cl_mem), &S_p.handle());
            clSetKernelArg(mmul_,  1, sizeof(cl_mem), &D_p.handle());
            clSetKernelArg(mmul_,  2, sizeof(cl_mem), &Mm1_tr_p.handle());
            clSetKernelArg(mmul_,  3, sizeof(cl_mem), &Mm2_p.handle());
            clSetKernelArg(mmul_,  4, sizeof(int),    &max_lambda);
            clSetKernelArg(mmul_,  5, sizeof(cl_mem), &Mi_L);
            clSetKernelArg(mmul_,  6, sizeof(cl_mem), &Mi_mLm1);
            clSetKernelArg(mmul_,  7, sizeof(int),    &l1);
            clSetKernelArg(mmul_,  8, sizeof(int),    &l2);
            clSetKernelArg(mmul_,  9, sizeof(cl_mem), &a.handle());
            clSetKernelArg(mmul_, 10, sizeof(cl_mem), &b.handle());
            clEnqueueNDRangeKernel(queue_, mmul_, 1, nullptr, &Nsegsiz, &Nlocal_, 0, nullptr, nullptr);
            clFinish(queue_);
        };
        
        // applies KPA preconditioner (two "kron-dots")
        auto inner_prec = [&](const clArrayView<Complex> x, clArrayView<Complex> y) -> void
        {
            // multiply by approximate inverse block
            
            clSetKernelArg(krd1_, 0, sizeof(cl_mem), &prec1a.handle());
            clSetKernelArg(krd1_, 1, sizeof(cl_mem), &prec2a.handle());
            clSetKernelArg(krd1_, 2, sizeof(cl_mem), &x.handle());
            clSetKernelArg(krd1_, 3, sizeof(cl_mem), &tmA.handle());
            clEnqueueNDRangeKernel(queue_, krd1_, 1, nullptr, &Nspline, nullptr, 0, nullptr, nullptr);
            clFinish(queue_);
            
            clSetKernelArg(krd2_, 0, sizeof(cl_mem), &prec1a.handle());
            clSetKernelArg(krd2_, 1, sizeof(cl_mem), &prec2a.handle());
            clSetKernelArg(krd2_, 2, sizeof(cl_mem), &y.handle());
            clSetKernelArg(krd2_, 3, sizeof(cl_mem), &tmA.handle());
            clEnqueueNDRangeKernel(queue_, krd2_, 1, nullptr, &Nspline, nullptr, 0, nullptr, nullptr);
            clFinish(queue_);
            
            clSetKernelArg(krdv_, 0, sizeof(Complex), &E_);
            clSetKernelArg(krdv_, 1, sizeof(cl_mem),  &Dl1.handle());
            clSetKernelArg(krdv_, 2, sizeof(cl_mem),  &Dl2.handle());
            clSetKernelArg(krdv_, 3, sizeof(cl_mem),  &y.handle());
            clEnqueueNDRangeKernel(queue_, krdv_, 1, nullptr, &Nspline, nullptr, 0, nullptr, nullptr);
            clFinish(queue_);
            
            clSetKernelArg(krd1_, 0, sizeof(cl_mem), &prec1b.handle());
            clSetKernelArg(krd1_, 1, sizeof(cl_mem), &prec2b.handle());
            clSetKernelArg(krd1_, 2, sizeof(cl_mem), &y.handle());
            clSetKernelArg(krd1_, 3, sizeof(cl_mem), &tmA.handle());
            clEnqueueNDRangeKernel(queue_, krd1_, 1, nullptr, &Nspline, nullptr, 0, nullptr, nullptr);
            clFinish(queue_);
            
            clSetKernelArg(krd2_, 0, sizeof(cl_mem), &prec1b.handle());
            clSetKernelArg(krd2_, 1, sizeof(cl_mem), &prec2b.handle());
            clSetKernelArg(krd2_, 2, sizeof(cl_mem), &y.handle());
            clSetKernelArg(krd2_, 3, sizeof(cl_mem), &tmA.handle());
            clEnqueueNDRangeKernel(queue_, krd2_, 1, nullptr, &Nspline, nullptr, 0, nullptr, nullptr);
            clFinish(queue_);
        };
        
        // computes norm of the vector
        auto compute_norm = [&](const clArrayView<Complex> x) -> double
        {
            // multiply
            //     |x|² -> nrm
            clSetKernelArg(norm_, 0, sizeof(cl_mem), &x.handle());
            clSetKernelArg(norm_, 1, sizeof(cl_mem), &nrm.handle());
            clEnqueueNDRangeKernel(queue_, norm_, 1, nullptr, &Nsegsiz, &Nlocal_, 0, nullptr, nullptr);
            nrm.EnqueueDownload(queue_);
            clFinish(queue_);
            
            // return square root of the sum
            return std::sqrt(sum(nrm));
        };
        
        // computes scalar product of two arrays
        auto scalar_product = [&](const clArrayView<Complex> x, const clArrayView<Complex> y) -> Complex
        {
            // multiply
            //     x * y -> tmp
            clSetKernelArg(spro_, 0, sizeof(cl_mem), &x.handle());
            clSetKernelArg(spro_, 1, sizeof(cl_mem), &y.handle());
            clSetKernelArg(spro_, 2, sizeof(cl_mem), &tmp.handle());
            clEnqueueNDRangeKernel(queue_, spro_, 1, nullptr, &Nsegsiz, &Nlocal_, 0, nullptr, nullptr);
            tmp.EnqueueDownload(queue_);
            clFinish(queue_);
            
            // sum the product of the arrays
            return sum(tmp);
        };
        
        // weighted sum of two arrays
        auto axby = [&](Complex a, clArrayView<Complex> x, Complex b, const clArrayView<Complex> y) -> void
        {
            // multiply
            //     a * x + b * y -> z
            clSetKernelArg(axby_, 0, sizeof(Complex), &a);
            clSetKernelArg(axby_, 1, sizeof(cl_mem),  &x.handle());
            clSetKernelArg(axby_, 2, sizeof(Complex), &b);
            clSetKernelArg(axby_, 3, sizeof(cl_mem),  &y.handle());
            clEnqueueNDRangeKernel(queue_, axby_, 1, nullptr, &Nsegsiz, nullptr, 0, nullptr, nullptr);
            clFinish(queue_);
        };
        
        // solve using the CG solver
        n[ill] = cg_callbacks < clArray<Complex>, clArrayView<Complex> >
        (
            rview,                  // rhs
            zview,                  // solution
            cmd_.prec_itertol,      // preconditioner tolerance
            0,                      // min. iterations
            Nsegsiz,                // max. iteration
            inner_prec,             // preconditioner
            inner_mmul,             // matrix multiplication
            false,                  // verbose output
            compute_norm,           // norm of an array
            scalar_product,         // scalar product of two arrays
            axby,                   // weighted sum of two arrays
            new_opencl_array        // allocate and connect a new array
        );
        
        // download data arrays from the GPU
        zview.EnqueueDownload(queue_);
        clFinish(queue_);
        
        // free GPU memory
        rview.disconnect();
        zview.disconnect();
        prec1a.disconnect();
        prec2a.disconnect();
        prec1b.disconnect();
        prec2b.disconnect();
        Dl1.disconnect();
        Dl2.disconnect();
    }
    
    // free GPU memory
    tmp.disconnect();
    nrm.disconnect();
    tmA.disconnect();
    D_p.disconnect();
    S_p.disconnect();
    Mm1_tr_p.disconnect();
    Mm2_p.disconnect();
    Mi_L.disconnect();
    Mi_mLm1.disconnect();
    
    // broadcast inner preconditioner iterations
    par_.sync(n.data(), 1, l1_l2_.size());
    
    // inner preconditioner info (max and avg number of iterations)
    std::cout << " | ";
    std::cout << std::setw(5) << (*std::min_element(n.begin(), n.end()));
    std::cout << std::setw(5) << (*std::max_element(n.begin(), n.end()));
    std::cout << std::setw(5) << format("%g", std::accumulate(n.begin(), n.end(), 0) / float(n.size()));
}

#endif
